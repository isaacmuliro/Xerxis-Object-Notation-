# Xon Language Project Documentation

## 1. Project Overview
**Xon** is a custom, lightweight configuration language designed to be a "richer" and more developer-friendly alternative to JSON. It is built using C, utilizing a hand-written Lexer and a LALR(1) parser generated by the Lemon Parser Generator.

The goal of Xon is to provide the structure of JSON but with the flexibility of languages like JavaScript or C, supporting features like comments, hexadecimal numbers, and unquoted keys.

---

## 2. Language Features
Xon supports a superset of JSON features:

### 2.1 Standard Data Types
*   **Objects:** Key-value pairs enclosed in `{}`.
*   **Lists:** Ordered arrays enclosed in `[]`.
*   **Strings:** Double-quoted text `"Hello World"`. Supports escape sequences (`\n`, `\t`, `\"`, `\\`).
*   **Numbers:** Standard decimal numbers (`123`, `45.67`).
*   **Booleans:** `true` and `false`.
*   **Null:** `null`.

### 2.2 "Rich" Features (Improvements over JSON)
*   **Comments:** C-style single-line comments (`// ...`) are supported and ignored by the parser.
*   **Hexadecimal Numbers:** Native support for hex values (e.g., `0xFF`, `0x1A`), automatically converted to decimal values.
*   **Trailing Commas:** Lists and Objects can end with a comma (e.g., `[1, 2,]`), making programmatic generation and editing easier.
*   **Unquoted Keys:** Object keys do not require quotes if they are valid identifiers (alphanumeric + underscore), e.g., `{ name: "Xon" }` instead of `{ "name": "Xon" }`.

---

## 3. Architecture

The project consists of three main components:

### 3.1 The Lexer (`lexer.c`, `lexer.h`)
*   **Role:** Reads the raw input file character by character and groups them into "Tokens".
*   **Key Functions:**
    *   `xon_get_token`: The main state machine. It skips whitespace/comments and identifies tokens like `LBRACE`, `STRING`, `NUMBER`, `TRUE`, etc.
    *   **Line Tracking:** Maintains a `currentLine` counter to report precise error locations.
    *   **String Parsing:** Handles buffer allocation and escape sequence processing.

### 3.2 The Parser (`xon.lemon`)
*   **Role:** Defines the grammar rules of the language. It takes tokens from the Lexer and builds the Abstract Syntax Tree (AST).
*   **Tool:** Built using **Lemon**, a parser generator (similar to Yacc/Bison but thread-safe and simpler).
*   **Grammar Rules:**
    *   Defines hierarchy: `root -> object | list`.
    *   Handles recursion for lists and objects.
    *   Manages memory allocation for AST nodes (`new_node`, `link_node`).

### 3.3 The AST & Driver (`main.c`)
*   **Role:** The entry point of the application. It orchestrates the Lexer and Parser, manages memory, and provides utilities to traverse the data.
*   **Data Structure (`DataNode`):** A recursive struct capable of holding any Xon data type.
    ```c
    typedef struct DataNode {
        enum DataType type;
        struct DataNode *next; // Linked list pointer for siblings
        union {
            char *s_val;
            double n_val;
            int b_val;
            struct {
                struct DataNode *key;
                struct DataNode *value;
            } aggregate;
        } data;
    } DataNode;
    ```
*   **Memory Management:** Includes a recursive `free_xon_ast` function to prevent memory leaks.
*   **Visitor Pattern:** Implements `xon_get_key` to allow dynamic querying of the data structure (e.g., `xon_get_key(root, "server_name")`).

---

## 4. Build Instructions

### Prerequisites
*   GCC Compiler
*   Lemon Parser Generator (included in `tools/` or compiled separately)

### Compilation Steps
1.  **Generate the Parser:**
    Use Lemon to convert the grammar file into C code.
    ```bash
    ./tools/lemon xon.lemon
    ```
    *Output:* `xon.c`, `xon.h`, `xon.out`

2.  **Compile the Project:**
    Compile the main driver, lexer, and link them together.
    ```bash
    gcc -o xon main.c lexer.c
    ```

3.  **Run:**
    ```bash
    ./xon test.xon
    ```

---

## 5. Example Usage

### Input File (`test.xon`)
```javascript
{
    server_name: "XonServer",   // Unquoted key
    max_memory: 0xFF,           // Hex number (255)
    is_active: true,            // Boolean
    features: [
        "fast",
        "simple",               // Trailing comma
    ]
}
```





 # Feature RoadMap
 -Error Recovery (implement a fallback in lemon to handle syntax errors more gracefully)
 -Serialization (Add a function to write the ATS back to a .xon file)
 -Standard Library (Create a shared library [libxon.so]) so other C/C++ programs can easily include Xon configuration support