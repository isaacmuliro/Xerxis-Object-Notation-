// The name of the parser function Lemon will generate
%name xonParser

%token_type {Token}
%extra_argument { DataNode **pResult }

%syntax_error {
    fprintf(stderr, "Syntax Error at line %d near token '%s'\n", TOKEN.line, TOKEN.s_val ? TOKEN.s_val : "unknown");
}

%type root {DataNode*}
%type object {DataNode*}
%type list {DataNode*}
%type pair_list {DataNode*}
%type value_list {DataNode*}
%type pair {DataNode*}
%type value {DataNode*}

%include {
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

typedef struct Token {
    char* s_val;
    double n_val;
    int line;
} Token;

enum DataType {
    TYPE_OBJECT,
    TYPE_LIST,
    TYPE_STRING,
    TYPE_NUMBER,
    TYPE_BOOL, // NEW
    TYPE_NULL  // NEW
};

typedef struct DataNode {
    enum DataType type;
    struct DataNode *next; // NEW: Moved outside union to allow linking any node type
    union {
        char *s_val;
        double n_val;
        int b_val; // NEW: For booleans (1 or 0)
        struct {
            struct DataNode *key;
            struct DataNode *value;
        } aggregate;
    } data;
} DataNode;

DataNode* new_node(enum DataType type) {
    DataNode* n = (DataNode*)malloc(sizeof(DataNode));
    if (n) {
        memset(n, 0, sizeof(DataNode));
        n->type = type;
    }
    return n;
}

DataNode* link_node(DataNode* head, DataNode* item) {
    if (!head) return item;
    DataNode* current = head;
    while (current->next) { // NEW: Use the outer 'next' pointer
        current = current->next;
    }
    current->next = item;
    return head;
}
}

// --- GRAMMAR RULES ---

root ::= object(A) . { *pResult = A; }
root ::= list(A) .   { *pResult = A; }

// --- OBJECT RULES ---
object(A) ::= LBRACE pair_list(B) RBRACE . { A = B; }
object(A) ::= LBRACE pair_list(B) COMMA RBRACE . { A = B; } // NEW: Trailing comma support
object(A) ::= LBRACE RBRACE . { A = new_node(TYPE_OBJECT); }

pair_list(A) ::= pair(B) . {
    A = new_node(TYPE_OBJECT);
    if (A) A->data.aggregate.value = B;
}
pair_list(A) ::= pair_list(B) COMMA pair(C) . {
    A = B;
    link_node(A->data.aggregate.value, C);
}

pair(A) ::= STRING(B) COLON value(C) . {
    A = new_node(TYPE_OBJECT);
    if (A) {
        A->data.aggregate.key = new_node(TYPE_STRING);
        A->data.aggregate.key->data.s_val = B.s_val;
        A->data.aggregate.value = C;
    }
}

// NEW: Unquoted keys (Identifiers)
pair(A) ::= IDENTIFIER(B) COLON value(C) . {
    A = new_node(TYPE_OBJECT);
    if (A) {
        A->data.aggregate.key = new_node(TYPE_STRING);
        A->data.aggregate.key->data.s_val = B.s_val;
        A->data.aggregate.value = C;
    }
}

// --- LIST RULES ---
list(A) ::= LBRACKET value_list(B) RBRACKET . {
    A = new_node(TYPE_LIST);
    if (A) A->data.aggregate.value = B;
}
list(A) ::= LBRACKET value_list(B) COMMA RBRACKET . { // NEW: Trailing comma support
    A = new_node(TYPE_LIST);
    if (A) A->data.aggregate.value = B;
}
list(A) ::= LBRACKET RBRACKET . { A = new_node(TYPE_LIST); }

value_list(A) ::= value(B) . { A = B; }
value_list(A) ::= value_list(B) COMMA value(C) . { A = link_node(B, C); }

// --- VALUE RULES ---
value(A) ::= STRING(B) . {
    A = new_node(TYPE_STRING);
    if (A) A->data.s_val = B.s_val;
}
value(A) ::= NUMBER(B) . {
    A = new_node(TYPE_NUMBER);
    if (A) A->data.n_val = B.n_val;
}
value(A) ::= object(B) . { A = B; }
value(A) ::= list(B) . { A = B; }

// NEW: Boolean and Null rules
value(A) ::= TRUE . {
    A = new_node(TYPE_BOOL);
    if (A) A->data.b_val = 1;
}
value(A) ::= FALSE . {
    A = new_node(TYPE_BOOL);
    if (A) A->data.b_val = 0;
}
value(A) ::= NULL_VAL . {
    A = new_node(TYPE_NULL);
}